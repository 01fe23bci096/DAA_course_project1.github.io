<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Hello, I'm Riya Magadum üëã</h1>
        <p>I am passionate about technology and problem-solving. Here's a glimpse of my work:</p>
    </header>

    <section>
        <h2>üõ†Ô∏è Projects</h2>
        <ul>
            <li><strong>Project 1</strong>: There is a need for a sustainable, data-driven waste management system to achieve a cleaner, more efficient, and reliant smart city.</li>
        </ul>

        <h2>üöÄ Skills</h2>
        <ul>
            <li>C++, Python, JavaScript</li>
            <li>Data Structures and Algorithms</li>
            <li>Web Development (React.js, Node.js)</li>
        </ul>

        <h2>üåê Find Me Online</h2>
        <ul>
            <li><a href="https://github.com/01fe23bci096" target="_blank">GitHub</a></li>
            <li><a href="https://linkedin.com/in/www.linkedin.com/in/riya-magadum-762486343" target="_blank">LinkedIn</a></li>
        </ul>

        <h2>Portfolio Topic</h2>
        <dl>
            <dt>Course Name</dt>
            <dd>Algorithmic Problem Solving</dd>

            <dt>Course Code</dt>
            <dd>15ECSP204</dd>

            <dt>Name</dt>
            <dd>Riya Magadum</dd>

            <dt>SRN</dt>
            <dd>01FE23BCI096</dd>

            <dt>Course Instructor</dt>
            <dd>Prof. K M M Rajashekharaiah</dd>

            <dt>University</dt>
            <dd>KLE Technological University</dd>

            <dt>Portfolio Topic/Domain</dt>
            <dd>DAA course project</dd>
        </dl>


        

        
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
        }
        button:hover {
            background-color: #0056b3;
        }
        .content {
            display: none;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: -10px;
            background-color: #f9f9f9;
        }
    </style>
    <script>
        function toggleContent(id) {
            const content = document.getElementById(id);
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
        }
    </script>
</head>
<body>
    <h1>Data Structures and Algorithms</h1>

    <button onclick="toggleContent('intro')">Introduction to the Course</button>
    <div id="intro" class="content">
        <p>This course provides a comprehensive understanding of data structures and algorithms, emphasizing their design, analysis, and real-world applications. It covers foundational principles in mathematics, computer science, and engineering to equip students with the skills to tackle computational problems effectively.</p>
    </div>

    <button onclick="toggleContent('course-highlights')">Course Highlights</button>
    <div id="course-highlights" class="content">
        <h2>Core Concepts</h2>
        <ul>
            <li><strong>Algorithm Design:</strong> Focus on key paradigms like divide-and-conquer, dynamic programming, greedy algorithms, and backtracking.</li>
            <li><strong>Efficiency Analysis:</strong> Understanding time and space complexities (e.g., O(1), O(n log n), O(2^n)) to assess performance.</li>
            <li><strong>Computational Techniques:</strong> Recursive solutions for problems like Fibonacci series, iterative methods for looping tasks, and backtracking for exhaustive search (e.g., solving mazes).</li>
        </ul>
        <h2>Data Structures</h2>
        <ul>
            <li><strong>Linear Structures:</strong> Arrays, linked lists, stacks, and queues for basic storage and sequential operations.</li>
            <li><strong>Hierarchical Structures:</strong> AVL trees, red-black trees, and heaps for balanced and efficient data handling.</li>
            <li><strong>Graph Structures:</strong> Representations (adjacency lists/matrices), traversal methods (DFS, BFS), and spanning trees for network modeling.</li>
            <li><strong>Specialized Structures:</strong> Fenwick trees, segment trees, and tries for fast data queries and prefix searches.</li>
        </ul>
        <h2>Algorithms</h2>
        <ul>
            <li><strong>Sorting:</strong> Efficient algorithms like merge sort and quicksort to organize data.</li>
            <li><strong>String Search:</strong> Pattern-matching techniques like KMP and Rabin-Karp for applications in text analysis and cybersecurity.</li>
            <li><strong>Graph Algorithms:</strong> Dijkstra's and Kruskal's algorithms for finding shortest paths and building efficient networks.</li>
        </ul>
        <h2>Applications</h2>
        <ul>
            <li><strong>Web Development:</strong> Database indexing and query optimization using sorting and searching algorithms.</li>
            <li><strong>Networking:</strong> Graph algorithms for optimal routing paths in communication networks.</li>
            <li><strong>Game Development:</strong> Tree-based structures for managing game states or events dynamically.</li>
            <li><strong>Cybersecurity:</strong> Intrusion detection systems leveraging string-matching algorithms.</li>
            <li><strong>Data Analytics:</strong> Efficient data aggregation using Fenwick trees or sparse tables.</li>
            <li><strong>Machine Learning:</strong> Priority-based operations like decision tree construction using heaps.</li>
        </ul>
    </div>

    <button onclick="toggleContent('key-reflections')">Key Learning Reflections</button>
    <div id="key-reflections" class="content">
        <h2>Problem-Solving Techniques</h2>
        <p>Recursion, iteration, and backtracking mimic real-world processes. For example, recursion models repetitive tasks like Fibonacci computation, while backtracking explores all possible solutions, such as solving Sudoku.</p>

        <h2>Efficiency and Growth Classes</h2>
        <p>Algorithms are evaluated by their resource usage. A linear algorithm (O(n)) scales better than a quadratic one (O(n¬≤)) for large datasets. Space-efficient algorithms reduce memory requirements, balancing performance.</p>

        <h2>Design Principles</h2>
        <ul>
            <li><strong>Modularity:</strong> Breaking problems into independent parts for easier debugging and scaling.</li>
            <li><strong>Abstraction:</strong> Focusing on high-level design to simplify complexity.</li>
            <li><strong>Optimization:</strong> Striking a balance between performance and simplicity.</li>
        </ul>

        <h2>Hierarchical Data Structures</h2>
        <ul>
            <li><strong>Binary Trees:</strong> Efficient for searching and data management.</li>
            <li><strong>AVL/Red-Black Trees:</strong> Self-balancing for consistent performance.</li>
            <li><strong>Tries:</strong> Effective for prefix-based tasks like autocomplete.</li>
        </ul>

        <h2>Array Query Algorithms</h2>
        <p>Segment trees and Fenwick trees enable fast query operations, vital for applications like stock analysis or real-time data updates.</p>

        <h2>Trees vs. Graphs</h2>
        <ul>
            <li><strong>Trees:</strong> Simplified hierarchical relationships, e.g., file systems.</li>
            <li><strong>Graphs:</strong> Versatile and used for modeling networks, social connections, or transportation systems.</li>
        </ul>

        <h2>Sorting and Searching</h2>
        <p>Sorting enables efficient data access, while searching helps locate specific elements quickly. Examples: ranking systems in search engines, e-commerce filters.</p>

        <h2>Graph Algorithms</h2>
        <ul>
            <li><strong>Spanning Trees:</strong> Used in minimal-cost network design.</li>
            <li><strong>Shortest Paths:</strong> Algorithms like Dijkstra's are used in navigation systems and logistics.</li>
        </ul>

        <h2>Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Divide-and-Conquer:</strong> Breaking problems into smaller, manageable parts.</li>
            <li><strong>Dynamic Programming:</strong> Solving overlapping subproblems efficiently.</li>
            <li><strong>Greedy Algorithms:</strong> Optimal local choices for fast solutions, such as in scheduling tasks.</li>
        </ul>
    </div>

    <button onclick="toggleContent('reflection-questions')">Reflection Questions</button>
    <div id="reflection-questions" class="content">
        <ul>
            <li><strong>Choosing Efficient Approaches:</strong> Understanding problem constraints and using Big-O analysis helps select the right algorithm. For large datasets, prioritize logarithmic or linear complexities.</li>
            <li><strong>Balancing Conflicting Constraints:</strong> Trade-offs like memory vs. speed are addressed by hybrid solutions, e.g., caching frequently used data while keeping memory usage low.</li>
            <li><strong>Evaluating Solutions:</strong> Criteria include accuracy, efficiency, scalability, maintainability, and robustness. A strong solution balances these aspects.</li>
            <li><strong>Adapting Existing Solutions:</strong> Modular and reusable designs simplify adapting algorithms to new challenges. Testing ensures reliability.</li>
            <li><strong>Pattern Recognition in Data:</strong> Clustering, graph representations, or tables help identify patterns and structures for efficient algorithm design.</li>
            <li><strong>Simplicity vs. Optimization:</strong> Begin with simple, understandable solutions. Optimize only when scalability or performance demands it.</li>
            <li><strong>Problem Decomposition:</strong> Breaking problems into smaller components aids understanding and parallel development, making solutions scalable and easier to test.</li>
            <li><strong>Managing Trade-offs:</strong> Balancing time complexity, memory usage, and simplicity depends on the problem‚Äôs specific needs and constraints.</li>
            <li><strong>Addressing Limitations:</strong> Testing edge cases and stress-testing reveal weaknesses, which can be resolved by refining the algorithm or switching to better alternatives.</li>
            <li><strong>Applying Knowledge Across Domains:</strong> Core algorithmic principles, like graph traversal or dynamic programming, are applicable across diverse fields like logistics, networking, and AI.</li>
            <li><strong>Innovation vs. Reliance on Standards:</strong> Innovate when unique problems arise; use established solutions for common tasks. Consider the potential impact and complexity of the problem.</li>
        </ul>
    </div>
</body>
</html>




 <blockquote>‚ÄúThe only way to do great work is to love what you do.‚Äù ‚Äì Steve Jobs</blockquote>
